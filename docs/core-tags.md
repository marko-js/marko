# Core tags and attributes

Marko provides a number of tags

## Control flow

### `<if>`, `<else-if>`, `<else>`

The `<if>`, `<else-if>`, and `<else>` tags provide conditional control-flow for templates.

```marko
<if(arriving)>
    <div>Hey there</div>
</if>
<else-if(leaving)>
    <div>Bye now</div>
</else-if>
<else>
    <div>What's up?</div>
</else>
```

Conditionals may also be applied as attributes:

```marko
<div if(arriving)>Hey there</div>
<div else-if(leaving)>Bye now</div>
<div else>What's up?</div>
```

And support complex expressions:

```marko
<if(Math.random() > 0.5)>
    <div>50-50 chance of seeing this</div>
</if>
```

### `<for>`

The `<for>` tag allows you to map an iterable, object properties or a range of numbers into a template. Like some of the other core tags, `<for>` relies on [tag parameters](./syntax.md#tag-body-parameters) to provide data about the current iteration to its body.

#### Iterating over a list

Much like the [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop in javascript, providing an `of` attribute will iterate over the provided array/iterable. For convenience both the current item, index, and the current list will be provided as [tag parameters](./syntax.md#tag-body-parameters).

```marko
<ul>
    <for|color, index| of=colors>
        <li>${index}: ${color}</li>
    </for>
</ul>
```

With the following value for `colors`:

```js
const colors = ["red", "green", "blue"];
```

The output HTML would be the following:

```html
<ul>
  <li>red</li>
  <li>green</li>
  <li>blue</li>
</ul>
```

> **Pro Tip**: The `<for>` tag with an `of` attribute can iterate over any iterable just like the JavaScript [`for...of`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop. In order to iterate over other "array like" objects (ones that just have a `length` property for example) you can use [`Array.from`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).
>
> ```
> <for|letter, index| of=Array.from({ 0: "a", 1: "b", length: 2 })>
>   ${index + 1}: ${letter}
> </for>
> ```

#### Iterating over an objects properties

Much like the [`for...in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in) loop in javascript, providing an `in` attribute will iterate over the provided objects properties. For convenience both the current property name and its value will be provided as [tag parameters](./syntax.md#tag-body-parameters).

```marko
<ul>
    <for|name, enabled| in=settings>
        <li>${name}: ${enabled ? "on" : "off"}</li>
    </for>
</ul>
```

With the following value for `settings`:

```js
const settings = {
  "Dark Mode": false,
  Fullscreen: true
};
```

The output HTML would be the following:

```html
<ul>
  <li>Dark Mode: off</li>
  <li>Fullscreen: on</li>
</ul>
```

#### Iterating between a range of numbers

The final variant allows you to iterate between two numbers. You must provide a `from` and `to` attribute, along side an optional `step` attribute. If not specified, `step` defaults to 1. For convenience both the current number in the range will be provided as [tag parameters](./syntax.md#tag-body-parameters).

```marko
<ul>
    <for|i| from=0 to=10>
        <li>${i}</li>
    </for>
</ul>
```

```marko
<ul>
    <for|i| from=0 to=10 step=2>
        <li>${i}</li>
    </for>
</ul>
```

```marko
<ul>
    <for|i| from=0 to=(myArray.length - 1)>
        <li>${myArray[i]}</li>
    </for>
</ul>
```

### `<while>`

Any element can be repeated until a condition is met by using the `while` directive. The directive can be applied as an element or as an attribute.

_Applied as an attribute:_

```marko
$ var n = 0;

<ul>
    <li while(n < 4)>
        ${n++}
    </li>
</ul>
```

_Applied as an element:_

```marko
$ var n = 0;

<ul>
    <while(n < 4)>
        <li>${n++}</li>
    </while>
</ul>
```

### `body-only-if`

If you find that you have a wrapper element that is conditional, but whose body should always be rendered then you can use the `body-only-if` attribute to handle this use case. For example, to only render a wrapping `<a>` tag if there is a valid URL then you could do the following:

```marko
<a href=input.linkUrl body-only-if(!input.linkUrl)>
    Some body content
</a>
```

Given a value of `"http://localhost/"` for the `input.linkUrl` variable: , the output would be the following:

```marko
<a href="http://localhost/">
    Some body content
</a>
```

Given a value of `undefined` for the `input.linkUrl` variable: , the output would be the following:

```marko
Some body content
```

## JavaScript

The following tags are always written using the [concise syntax](./concise.md), even when using HTML syntax for tags that generate HTML output.

### `import`

> **Static:** The code generated by `import` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `import` tag is used to access data and functions from external files. It follows the same syntax as the [JavaScript `import` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).

```marko
import sum from './utils/sum';
<div>The sum of 2 + 3 is ${sum(2, 3)}</div>
```

<!-- ### `<export>`
> **Static:** The code generated by `export` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `export` tag is used to export values from the template.  It follows the same syntax as the [JavaScript `export` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export), but only named exports are supported (the default export is the template).

```marko
export var route = '/about';

<!doctype html>
<html>
    <body>
        <h1>About us</h1>
    </body>
</html>
``` -->

## `<${dynamic}>`

```marko
<${useDiv ? 'div' : 'span'}>
    Hello there!
</>
```

The `<${dynamic}>` tag is used to render a tag, component, or transcluded content that isn't determined until runtime.

### Dynamic components

The `<${dynamic}>` tag can be used to embed another template in the current template:

```marko
import componentA from "./path/to/component-a.marko";
import componentB from "./path/to/component-b.marko";

<${useA ? componentA : componentB} name="Frank"/>
```

You can also switch between a normal HTML tag and a Marko component:

```marko
import FancyButton from "./path/to/fancy-button.marko";

<${isFancy ? FancyButton : 'button'}>
    Button text
</>
```

### Layouts and transcluded content

You can pass transcluded content to a tag using nested attribute tags which are denoted by the `@` symbol:

_page.marko_

```marko
<layout>
    <@body>
        <h1>Hello Marko</h1>
    </@body>
</layout>
```

Then in your layout template you can render the transcluded content using the `<${dynamic}>` tag:

_layout.marko_

```marko
<!doctype html>
<html>
    <body>
        <!-- this comes from <@body> -->
        <${input.body}/>
    </body>
</html>
```

<!--
- You can use many nested attribute tags for multiple injection points
- You can have repeated nested attribute tags by using `marko-tag.json` (components only)
- You can add additional attributes to an nested attribute tag
- You can pass data to a nested attribute tag's body?
-->

### `<include-text>`

```marko
<include-text('./foo.txt')/>
```

Special HTML characters will be escaped. If you do not want escaping then use the `<include-html>` tag (see below).

### `<include-html>`

```marko
<include-html('./foo.html')/>
```

Special HTML characters will _not_ be escaped since the file is expected to be an HTML file.

### `<macro>`

Macro's allow for reusable fragments within an HTML template.
A macro can be defined using the `<macro>` tag, with a `name` attribute.

```marko
<macro name="greeting">
    <span>Welcome!</span>
</macro>
```

The above macro can then be used as if it was a regular `greeting` tag.

```marko
<greeting/>
<greeting/>

// Becomes
<span>Welcome!</span>
<span>Welcome!</span>
```

Macro's become more useful when combined with [tag parameters](./syntax.md#tag-body-parameters), allowing for more complex templates like so:

```marko
<macro|{ name, count }| name="greeting">
    <span>Hello ${name}! You have ${count} new messages.</span>
</macro>
```

This time the `<greeting>` macro is able to receive parameters from the outside, in this case `name` and `count`.

```marko
<greeting name="Frank" count=20/>

// Becomes
<span>
    Hello Frank! You have 10 new messages.
</span>
```

Macro's receive input similar to the root template, including a `renderBody` for displaying any provided body content.

```marko
<macro|{ renderBody }| name="special-heading">
    <h1>
        <${renderBody}/>!
    </h1>
</macro>

<p>
    <special-heading>
        Hello
    </special-heading>
</p>

// Becomes

<p>
    <h1>
        Hello!
    </h1>
</p>
```

## Async content

### `<await>`

The `<await>` tag is used to dynamically load in content from a data provider. The data provider can be a `Promise` or a `callback`. Once the provider returns it's results the children are rendered.

await-example.marko

```marko
$ var personPromise = new Promise((resolve, reject) => {
    setTimeout(function() {
        resolve({
            name: 'Frank'
        });
    }, 1000);
});

<await(person from personPromise)>
    <div>Hello ${person.name}!</div>
</await>
```

Advanced implementation:

- `<await>` tag signature
  - Basic usage: `<await(results from dataProvider)>...</await>`
  - Optional attributes
    - client-reorder `boolean`
    - arg `expression`
    - arg-\* `string`
    - method `string`
    - timeout `integer`
    - timeout-message `string`
    - error-message `string`
    - placeholder `string`
    - renderTimeout `function`
    - renderError `function`
    - renderPlaceholder `function`
    - name `string`
    - scope `expression`
    - show-after `string`
  - Optional child tags
    - `<await-placeholder>Loading...</await-placeholder>`
    - `<await-timeout>Request timed out</await-timeout>`
    - `<await-error>Request errored</await-error>`

## Comments

Standard HTML comments can be used to add comments to your template. The HTML comments will not show up in the rendered HTML.

Example comments:

```marko
<!-- This is a comment that will not be rendered -->
<h1>Hello</h1>
```

```js
// You can also use standard JavaScript-style comments
/*
 Block comments are also supported
 */
--Hello;
```

If you would like for your HTML comment to show up in the final output then you can use the custom `html-comment` tag.

### `<html-comment>`

_input.marko_

```marko
<html-comment>This is a comment that *will* be rendered</html-comment>
<h1>Hello</h1>
```

_output.html_

```html
<!--This is a comment that *will* be rendered-->
<h1>Hello</h1>
```

Alternatively, the `<marko-compiler-options>` tag may be used to configure comments for the entire template:

```marko
<marko-compiler-options preserve-comments/>
```

## Compiler options

### `marko-preserve-whitespace`

Whitespace can be preserved using the `preserve-whitespace` attribute:

```marko
<div marko-preserve-whitespace>
    All of this
    whitespace   will
    be preserved.
</div>
```

Alternatively, the `<marko-compiler-options>` tag may be used to configure whitespace for the entire template:

```marko
<marko-compiler-options preserve-whitespace/>
```

### `marko-body`

The `marko-body` attribute can be used to control how body content is parsed. The following values are supported:

- `html` - Body content will be parsed HTML (the default)
- `static-text` - Body content will be parsed as static text (HTML tags will be ignored). Placeholders will be ignored.
- `parsed-text` - Body content will be parsed as text (HTML tags will be ignored). Placeholders will not be ignored.

_input.marko_

```marko
<div marko-body="static-text">
    This is just one
    <span if(foo)>
            Hello ${THIS IS NOT VALID}!
    </span>
    big text block
</div>
```

_output.html_

```html
<div>
  This is just one &lt;span if(foo)&gt; Hello ${THIS IS NOT VALID}!
  &lt;/span&gt; big text block
</div>
```
